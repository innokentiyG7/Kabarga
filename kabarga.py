# -*- coding: utf-8 -*-
#Created on Thu Oct  6 13:59:11 2022
#Математическая программа для решения разных задач из теории чисел

from math import gcd as bltin_gcd
import numpy as np
from sympy.ntheory import factorint

def Vzaimro_prostie(a, b):
    if(bltin_gcd(a, b) == True):
        return ("Числа взаимно простые")
#print(Vzaimro_prostie(9,25))


def phi(p,q):
    #return m.lcm(p-1,q-1)
    return(p-1)*(q-1)



print("                                     .-++=++++:                                           ")
print("    :*#@@%*+=-:.                      .-====+=:                                           ")
print("    ##**##@@@@%@%=:                   .:-====+-                                           ")
print("    .::..-==+#@%@@@*=:                .:--==++-                                           ")
print("     .-:   -+::#@@%#%+..:.           .:-==++++-.                                          ")
print("      :*-.  .:. :#*#%#==**=      ....-==+***##=.                                          ")
print("       .+-.:-=+  .+*#*****=:.     .:-=++#%%%@%*-.                                         ")
print("         :=---*+  :-+#%#%%%#=: :...  ..:-==+###=.                                         ")
print("          .:-=++:.  :-=+*=*%@#*#===::=*++++-:..:.                                         ")
print("             ....=    .=+*#@%%@%%#+++*##%%#*+=-+*+==:.                                    ")
print("               :...     -=%##%%@#**+++**#*==: -**%#==+**+-:                               ")
print("                .     :-====%@@*=-=+=+*+==: +#++#*%*-=#@@%%#+:.                           ")
print("                       .-++**#++--=+++*+-::-:::-*%#%*+==+++++++=-:.                       ")
print("                   .    ..-==+::-:++=*+:::.. :+*#*=. .-==+=++----:.   ..  : .             ")
print("                   -:.    .::.:-=*+*==+-.:... . :  . :-=+***+==-:. .:*#*+=+#@@+           ")
print("                     .=:  .:-:-=+=+-+=:::===-:-====:--++**+#+*+=-.:.-@@@@@#*%%++          ")
print("                      .-:..::---=++=:..::----#=--:--=-=-++*=--::..::=+%%@@@%*=++          ")
print("                       ..: :.::--:::-..-:.:=-=-:.:::-.=-=--:-..      .:*@%#+*+:           ")
print("                        ::...::*+:.-:--:-:--=:-:-.-::-:--::::.. . ..:-+*#@#+.             ")
print("                       .::::.--=:.:::=-==+-+=++====-:--:=--=.: -.:= +%%%+:.               ")
print("                      .-:==--=*--=-===-:-+*+**%###***+*==:-.:... .. :=:.                  ")
print("                     . +*+===+===+==---:=-++*#*:.:==--.:-:.-.:--=:  ::                    ")
print("                     .:*#+++*+*#**++===-==***#%=:=*-.-===*#%@@%@+= .                      ")
print("                     :-+#%##**##*##*=+-=+****###%##%@%@%@@%*=:                            ")
print("                    ::.=*@#@%%#%%%##*=+***#%%@@@@@@@@@%#+:                                ")
print("                    ...=*#%@@%%*=:.:-##*+***++###%%*---:.                                 ")
print("                    ..:==*%@@%%*-    =**#*+*=:--=*===++=-:.. ...                          ")
print("                     .::-*@@%@%%+:   -*#%@@@#--: .:-=+*++=-:..                            ")
print("                     :=-+:*+%@@%+. ..-#@@%@@%+-  .:-+*###+-:.                             ")
print("                      ===:-+%@@%=. .-=#@@@@@#+: -:.=*%@%#*=:.                             ")
print("                    . -.-=*#%%@#%:.+*#@@@@@%*+=:#=-+%@@@%*=-.                             ")
print("                    . .---+%%%@##*#*%@%%%@@%%##+%=+@@@@@@#+:.                             ")
print("                    .::-==++#%###%#%%%%##%%@@%@@%=*@@@@@%*-.                              ")
print("Математическая программа Кабарга (версия 1.0)")
print("Разработчик - И. А. Герасимов")
print("1. Составление таблицы элементов по модулю для нахождения обратного элемента.")
print("2. Решение системы сравнений")
print("3. RSA: нахождение значений по известным n,e,m")
choice = int(input("Выбор опции: "))
if(choice == 1):
    """
    Составление таблицы элементов по модулю для нахождения обратного элемента.
    Т.е. n = 5
      1 2 3 4
    1 1 2 3 4
    2 2 4 1 3
    3 3 1 4 2
    4 4 3 2 1

    1^-1 =1 
    2 ^-1 = 3
    3 ^-1 = 2
    4 ^-1 = 4

    """    
    num = int(input("n: "))
    A = np.array([[0] * num] * num)
    for i in range(1,num):
        for j in range(1,num):
             A[i][j] = (i * j % num)
             
    for i in range(1,num):
        for j in range(1,num):
             A[i][j] = (i * j % num)      
    print(A)
elif(choice == 2):
    print("\nПример системы")
    print("x = 2 mod 5")
    print("x = 3 mod 7")
    print("x = 4 mod 9")
    print("\nРаботает только при 1*х и системе 3 на 3")
    n = 3
    print("\nВведите элементы Ai (Те которые перед nod)")
    A = []
    for i in range(n):
        A.append(int(input(f'a{i+1}: ')))
    print("\nВведите элементы Ni (Те которые после nod)")
    
    N = []
    for i in range(n):
        N.append(int(input(f'N{i+1}: ')))
    
    print(f'x1 = {N[0]}t + {A[0]}')
    print(f't = {N[0]}^-1 mod {N[1]}')
    print(f't = {pow(N[0], -1, N[1])} + {N[1]}k')
    
    print(f'x = {A[0]}+ {N[0]} * ({pow(N[0], -1, N[1])} + {N[1]}k)')
    print('Посчитайте: ')
    print("Пример: 1+2к. Сначала введите 1 потом 2")
    t1 = int(input(": "))
    t2 = int(input("k: "))
    print(f'\nx1 = {t1} + {t2}k')
    print(f'{t1} + {t2}k = {A[2]} mod {N[2]}')
    print(f'k = {N[1]}^-1 mod {N[2]}')
    print(f't = {pow(N[1], -1, N[2])} + {N[2]}t')
    print(f'x = {t1} + {t2}k = {t2}*({pow(N[1], -1, N[2])} + {N[2]}t) + {t1}')
    print('Посчитайте: ')
    t11 = int(input(": "))
    t22 = int(input("k: "))
    print(f'\nx = {t11} mod {t22}')


elif(choice == 3):
    n = int(input("n: "))
    e = int(input("e: "))
    m = int(input("m: "))
    pq = list(factorint(n))
    p,q = pq[0],pq[1]
    phiN = phi(p, q)
    d = pow(e,-1,phiN)
    c = pow(m,e,n)
    m1 = pow(c,d,n)
    print(f'p: {p}, q: {q}, n: {n}, phi(n): {phiN}, d: {d}, c: {c}, m1:{m1}')

    
else:
    print('exit')
    exit()
    
